{"code":"class AlphaVideo {\n    options = {\n        src: '',\n        autoplay: true,\n        loop: true,\n        canvas: document.createElement('canvas'),\n        width: 375,\n        height: 300,\n        onError: function () { },\n        onPlay: function () { }\n    };\n    radio;\n    video = document.createElement('video');\n    playing = false;\n    canvas = document.createElement('canvas');\n    gl = this.canvas.getContext('webgl');\n    constructor(options) {\n        this.options = Object.assign(this.options, options);\n        const { autoplay, canvas, width, height } = this.options;\n        this.radio = window.devicePixelRatio;\n        this.canvas = canvas;\n        this.canvas.width = width * this.radio;\n        this.canvas.height = height * this.radio;\n        this._initVideo();\n        this._initWebgl();\n        if (autoplay) {\n            this.video.play();\n        }\n    }\n    _initVideo() {\n        const { onPlay, onError, loop = false, src } = this.options;\n        const video = this.video;\n        video.autoplay = false;\n        video.muted = true;\n        video.volume = 0;\n        video.muted = true;\n        video.loop = loop;\n        video.setAttribute('x-webkit-airplay', 'true');\n        video.setAttribute('webkit-playsinline', 'true');\n        video.setAttribute('playsinline', 'true');\n        video.style.display = 'none';\n        video.src = src;\n        video.crossOrigin = 'anonymous';\n        video.addEventListener('canplay', () => {\n            this.playing = true;\n            onPlay && onPlay();\n        });\n        video.addEventListener('error', () => {\n            onError && onError();\n        });\n        video.addEventListener('play', () => {\n            window.requestAnimationFrame(() => {\n                this._drawFrame();\n            });\n        });\n        document.body.appendChild(video);\n        this.video = video;\n    }\n    _drawFrame() {\n        if (this.playing) {\n            this._drawWebglFrame();\n        }\n        window.requestAnimationFrame(() => {\n            this._drawFrame();\n        });\n    }\n    _drawWebglFrame() {\n        const gl = this.gl;\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.video);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    play() {\n        this.playing = true;\n        this.video.play();\n    }\n    pause() {\n        this.playing = false;\n        this.video.pause();\n    }\n    _initWebgl() {\n        if (!this.canvas) {\n            const { width, height } = this.options;\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = width * this.radio;\n            this.canvas.height = height * this.radio;\n            this.gl = this.canvas.getContext('webgl');\n            document.body.appendChild(this.canvas);\n        }\n        this.canvas.addEventListener('click', () => {\n            this.play();\n        });\n        const gl = this.gl;\n        gl.viewport(0, 0, this.options.width * this.radio, this.options.height * this.radio);\n        const program = this._initShaderProgram(gl);\n        gl.linkProgram(program);\n        gl.useProgram(program);\n        const buffer = this._initBuffer(gl);\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position);\n        const aPosition = gl.getAttribLocation(program, 'a_position');\n        gl.enableVertexAttribArray(aPosition);\n        gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.texture);\n        const aTexCoord = gl.getAttribLocation(program, 'a_texCoord');\n        gl.enableVertexAttribArray(aTexCoord);\n        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);\n        const texture = this._initTexture(gl);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        const scaleLocation = gl.getUniformLocation(program, 'u_scale');\n        gl.uniform2fv(scaleLocation, [this.radio, this.radio]);\n        this.gl = gl;\n    }\n    _createShader(gl, type, source) {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            throw gl.getShaderInfoLog(shader);\n        }\n        return shader;\n    }\n    _initShaderProgram(gl) {\n        const vsSource = `\r\n            attribute vec2 a_position;\r\n            attribute vec2 a_texCoord;\r\n            varying vec2 v_texCoord;\r\n            uniform vec2 u_scale;\r\n            void main(void) {\r\n                gl_Position = vec4(a_position, 0.0, 1.0);\r\n                v_texCoord = a_texCoord;\r\n            }\r\n        `;\n        const fsSource = `\r\n        precision lowp float;\r\n        varying vec2 v_texCoord;\r\n        uniform sampler2D u_sampler;\r\n        void main(void) {\r\n            gl_FragColor = vec4(texture2D(u_sampler, v_texCoord).rgb, texture2D(u_sampler, v_texCoord+vec2(-0.5, 0)).r);\r\n        }\r\n        `;\n        const vsShader = this._createShader(gl, gl.VERTEX_SHADER, vsSource);\n        const fsShader = this._createShader(gl, gl.FRAGMENT_SHADER, fsSource);\n        const program = gl.createProgram();\n        gl.attachShader(program, vsShader);\n        gl.attachShader(program, fsShader);\n        gl.linkProgram(program);\n        return program;\n    }\n    _initBuffer(gl) {\n        const positionVertice = new Float32Array([\n            -1.0, 1.0,\n            1.0, 1.0,\n            -1.0, -1.0,\n            1.0, -1.0\n        ]);\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, positionVertice, gl.STATIC_DRAW);\n        const textureBuffer = gl.createBuffer();\n        const textureVertice = new Float32Array([\n            0.5, 1.0,\n            1.0, 1.0,\n            0.5, 0.0,\n            1.0, 0.0\n        ]);\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, textureVertice, gl.STATIC_DRAW);\n        return {\n            position: positionBuffer,\n            texture: textureBuffer\n        };\n    }\n    _initTexture(gl) {\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        return texture;\n    }\n}\nexport default AlphaVideo;\n","references":["E:/myProject/npm-packages/video-to-canvas/src/types/index.ts"],"dts":{"name":"E:/myProject/npm-packages/video-to-canvas/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"import { IAlphaVideoConfig } from './types/index';\ndeclare class AlphaVideo {\n    options: {\n        src: string;\n        autoplay: boolean;\n        loop: boolean;\n        canvas: HTMLCanvasElement;\n        width: number;\n        height: number;\n        onError: () => void;\n        onPlay: () => void;\n    };\n    private radio;\n    private video;\n    private playing;\n    private canvas;\n    private gl;\n    constructor(options: IAlphaVideoConfig);\n    private _initVideo;\n    private _drawFrame;\n    private _drawWebglFrame;\n    play(): void;\n    pause(): void;\n    private _initWebgl;\n    private _createShader;\n    private _initShaderProgram;\n    private _initBuffer;\n    private _initTexture;\n}\nexport default AlphaVideo;\n"}}
